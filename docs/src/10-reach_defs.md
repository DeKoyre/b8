## Итерационный алгоритм для достигающих определений

Задача поиска достигающих определений важна в задаче анализа потоков данных и полезна при проведении многих оптимизаций, таких как поиск неинициализированных переменных или констант в конкретных точках программы.

**Определение** Определение `d` *достигает* точки `p`, если существует путь от непосредственно следующей за `d` точкой к `p` на котором `d` не уничтожается

Для поиска достигающих определений используется итеративный алгоритм для прямой задачи потока данных, на вход которому подается граф потока управления и множества `gen` (генерирующиеся определения) и `kill` (уничтожение определеий) для каждого блока.

Для хранения достигающих определений используется структура данных `HashSet<LabelValue>`

Передаточная функция имеет вид $f(x) = gen_b \cup (x \setminus kill_b)$

```csharp
protected override HashSet<LabelValue> TransferFunc(CFGNode node)
{
    var res = GenKill.GenLabels(node.Value);
    res.UnionWith(In[node].Except(GenKill.KillLabels(node.Value)));
    return res;
}
```

Оператор сбора для итерационного алгоритма -- объединение:

```csharp
protected override HashSet<LabelValue> MeetOp(List<CFGNode> nodes)
{
    return new HashSet<LabelValue>(nodes.SelectMany(n => Out[n]));
}
```

Таким образом, на выходе мы имеем множества `In` и `Out` достигающих опрелений для входа и выхода каждого блока.
